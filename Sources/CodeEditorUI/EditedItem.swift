//
//  File.swift
//
//
//  Created by Miguel de Icaza on 4/5/24.
//

import Foundation
#if canImport(UIKit)
import Runestone
import RunestoneUI
import TreeSitterGDScriptRunestone
import TreeSitter
import TreeSitterJSONRunestone
import TreeSitterMarkdownRunestone
import TreeSitterGLSLRunestone
#endif

import SwiftUI
/// Represents an edited item in the code editor, it uses a path to reference it, and expect that it
/// can be loaded and saved via the HostServices variable.
@Observable
public class EditedItem: HostedItem {
    public enum FileHint {
        case detect
        case gdscript
        case json
        case markdown
        case gdshader
    }
    /// Lines where breakpoint indicators are shown
    public var breakpoints: Set<Int>

    /// If set, a line to highlight, it means "This is current the debugger is stopped"
    public var currentLine: Int?

    /// Controls whether this language supports looking symbosl up
    public var supportsLookup: Bool

    /// - Parameters:
    ///  - path: the path that will be passed to the HostServices API to load and save the file
    ///  - content: Content that is loaded into the edited item
    ///  - editedItemDelegate: Provides services on behalf of this item
    ///  - fileHint: Hint to guess which kind of syntax and indentation to use
    ///  - breakpoints: List of breakpoints
    ///  - currentLine: The current line to scroll to on startup
    public init (path: String, content: String, editedItemDelegate: EditedItemDelegate?, fileHint: FileHint = .detect, breakpoints: Set<Int> = Set<Int>(), currentLine: Int? = nil) {
#if canImport(UIKit)
        switch fileHint {
        case .detect:
            if path.hasSuffix(".gd") || path.contains ("::"){
                language = TreeSitterLanguage.gdscript
                supportsLookup = true
            } else if path.hasSuffix (".md") {
                language = TreeSitterLanguage.markdown
                supportsLookup = false
            } else if path.hasSuffix(".gdshader") || path.hasSuffix(".gdshaderinc") || path.hasSuffix(".gdshaderinclude") {
                language = TreeSitterLanguage.glsl
                supportsLookup = false
            } else {
                language = nil
                supportsLookup = false
            }
        case .gdscript:
            language = TreeSitterLanguage.gdscript
            supportsLookup = true
        case .json:
            language = TreeSitterLanguage.json
            supportsLookup = false
        case .markdown:
            language = TreeSitterLanguage.markdown
            supportsLookup = false
        case .gdshader:
            supportsLookup = false
            language = TreeSitterLanguage.glsl
        }
#else
        supportsLookup = false
#endif
        self.editedItemDelegate = editedItemDelegate
        self.breakpoints = breakpoints
        self.currentLine = currentLine
        super.init (path: path, content: content)
#if canImport(UIKit)
        self.commands = runestoneCommands
#endif
    }

    /// Returns the filename that is suitable to be displayed to the user
    public var filename: String {
        if let s = path.lastIndex(of: "/"){
            return String (path [path.index(after: s)...])
        }
        return path
    }

    /// Returns a title suitable to be shown on the titlebar
    public override var title: String {
        filename
    }

    /// Delegate
    public var editedItemDelegate: EditedItemDelegate?

#if canImport(UIKit)
    public var language: TreeSitterLanguage? = nil
#endif

    /// List of detected functions, contains the name of the function and the line location
    public var functions: [(String,Int)] = []

    /// Detected errors
    public var errors: [Issue]? = nil

    /// Detected warnings
    public var warnings: [Issue]? = nil

    /// Whether the buffer has local changes
    public var dirty: Bool = false

#if canImport(UIKit)
    /// Runestone-specific commands used by TextViewUI.
    var runestoneCommands = TextViewCommands()
#endif

    /// Editor commands across Runestone/Monaco.
    public var commands: EditorCommands = NoopEditorCommands() {
        didSet {
            if pendingFocus {
                pendingFocus = false
                Task { @MainActor in
                    self.requestFocus()
                }
            }
        }
    }

    private var pendingFocus = false

    /// Sets the hint generated by the completion
    public var hint: String? = nil

    public static func == (lhs: EditedItem, rhs: EditedItem) -> Bool {
        lhs === rhs
    }

#if canImport(UIKit)
    var completionRequest: CompletionRequest? = nil
    var selectedCompletion = 0

    public func requestCompletion (at location: CGRect, on textView: TextView, prefix: String, completions: [CompletionEntry]) {
        completionRequest = CompletionRequest(at: location, on: textView, prefix: prefix, completions: completions, textViewCursor: textView.selectedRange.location)
        selectedCompletion = 0
    }

    public func cancelCompletion () {
        completionRequest = nil
    }
#endif

    /// This is used to set the validation result
    public func validationResult (functions: [(String,Int)], errors: [Issue]?, warnings: [Issue]?) {
        self.functions = functions
        self.errors = errors
        self.warnings = warnings
    }

    @MainActor
    public override func requestFindAndReplace() {
        commands.requestFindAndReplace()
    }

    @MainActor
    public override func requestFind () {
        commands.requestFind()
    }

    @MainActor
    public func requestFocus() {
        pendingFocus = true
        commands.onTextViewReady { [weak self] _ in
            guard let self else { return }
            self.pendingFocus = false
            self.commands.becomeFirstResponder()
        }
    }

    @MainActor
    public func editedTextChanged (on textView: EditorTextView) {
        dirty = true
        editedItemDelegate?.editedTextChanged(self, textView)
    }

    @MainActor
    public func started (on textView: EditorTextView) {
        editedItemDelegate?.editedTextChanged(self, textView)
    }

    @MainActor
    public func gutterTapped (on textView: EditorTextView, line: Int) {
        editedItemDelegate?.gutterTapped (self, textView, line)
    }

    @MainActor
    public func contextMenuRequested(on textView: EditorTextView, request: MonacoContextMenuRequest) {
        editedItemDelegate?.contextMenuRequested(self, on: textView, request: request)
    }

    @MainActor
    public func commandPaletteRequested(on textView: EditorTextView, request: MonacoCommandPaletteRequest) {
        editedItemDelegate?.commandPaletteRequested(self, on: textView, request: request)
    }

    public var textLocation = TextLocation(lineNumber: 0, column: 0)

    @MainActor
    public func editedTextSelectionChanged (on textView: EditorTextView) {
        if let newPos = textView.textLocation(at: textView.selectedRange.location) {
            textLocation = newPos
        }
#if canImport(UIKit)
        guard let completionRequest else { return }
        if textView.selectedRange.location != completionRequest.textViewCursor {
            self.cancelCompletion()
        }
#endif
    }

    @MainActor
    private func getDelimiter () -> String? {
        if path.hasSuffix(".gd") || path.contains ("::"){
            return "#"
        } else if path.hasSuffix(".gdshader") || path.hasSuffix(".gdshaderinc") {
            return "//"
        }
        return nil
    }
    
    @MainActor
    public func toggleInlineComment() {
        if let delimiter = getDelimiter() {
            commands.toggleInlineComment(delimiter)
        }
    }

    @MainActor
    public func indent() {
        commands.indent()
    }

    @MainActor
    public func unIndent() {
        commands.unIndent()
    }
}

/// Protocol describing the callbacks for the EditedItem
@MainActor
public protocol EditedItemDelegate: AnyObject {
    /// Editing has started for the given item, this is raised when the TextView has loaded
    func started (editedItem: EditedItem, textView: EditorTextView)
    /// Invoked when the text in the textView has changed, a chance to extract the data
    func editedTextChanged (_ editedItem: EditedItem, _ textView: EditorTextView)
    /// Invoked when the gutter is tapped, and it contains the line number that was tapped
    func gutterTapped (_ editedItem: EditedItem, _ textView: EditorTextView, _ line: Int)
    /// Invoked when the user has requested the "Lookup Definition" from the context menu in the editor, it contains the position where this took place and the word that should be looked up
    func lookup (_ editedItem: EditedItem, on: EditorTextView, at: EditorTextPosition, word: String)
    /// Invoked when Monaco requests a native context menu.
    func contextMenuRequested(_ editedItem: EditedItem, on: EditorTextView, request: MonacoContextMenuRequest)
    /// Invoked when Monaco requests a native command palette.
    func commandPaletteRequested(_ editedItem: EditedItem, on: EditorTextView, request: MonacoCommandPaletteRequest)
    /// Invoked when a closing is imminent on the UI
    func closing (_ editedItem: EditedItem)
    /// Requests that the given item be saved, returns nil on success or details on error, if newPath is not-nil, save to a new filename
    func save(editedItem: EditedItem, contents: String, newPath: String?) -> HostServiceIOError?
}

public extension EditedItemDelegate {
    func contextMenuRequested(_ editedItem: EditedItem, on: EditorTextView, request: MonacoContextMenuRequest) {
        _ = editedItem
        _ = on
        _ = request
    }

    func commandPaletteRequested(_ editedItem: EditedItem, on: EditorTextView, request: MonacoCommandPaletteRequest) {
        _ = editedItem
        _ = on
        _ = request
    }
}

public struct Issue {
    public enum Kind {
        case warning
        case error
    }
    var kind: Kind
    var col, line: Int
    var message: String

    public init (kind: Kind, col: Int, line: Int, message: String) {
        self.kind = kind
        self.col = col
        self.line = line
        self.message = message
    }
}
